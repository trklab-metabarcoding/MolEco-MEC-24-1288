{
  "hash": "360bf809aa89e5ab9bde869c1729dc2a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Building the BOLD dataset\"\nformat: html\n---\n\n\n\n\nThis notebook queries the BOLD API to fetch all the plant specimen data, including metadata and sequences. We clean as we go to correct for errors in the data on BOLD and adjust for some data being held in private projects on BOLD.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## First check for the required packages, install if needed, and load the libraries.\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"sangerseqR\")\nremotes::install_github(\"ropensci/bold\")\nremotes::install_github(\"ropensci/taxize\")\n\nif (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(maps, ggplot2, dplyr, countrycode, data.table, raster)\n```\n:::\n\n\n\n\n## Set up directory\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir.create(file.path(\"./family_csvs\"))\nsetDTthreads(threads = 6) # if you are working on cluster, this will allow data.table to multithread\n```\n:::\n\n\n\n\n## Step 1: Obtain a list of plant phyla in BOLD from which to pull records\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Name BOLD plant phyla\nboldphyla <- c(\"Anthocerotophyta\", \"Bryophyta\", \"Cycadophyta\", \"Ginkgophyta\",  \"Magnoliophyta\", \"Marchantiophyta\", \"Pinophyta\", \"Pteridophyta\", \"Tracheophyta\") #\"Gnetophyta\", \"Psilophyta\", \"Lycopodiophyta\" # these were previously listed a families but are now nested under other families\nlength(boldphyla)\n```\n:::\n\n\n\n\n## Step 2: retrieve all families descending from a vector of Phyla.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout0 <- vector(\"list\", length(boldphyla))\n\nfor(i in 1:length(boldphyla)){\n\ttempx<-taxize::downstream(boldphyla[i], db = \"bold\", downto = \"family\")\n\tout0[[i]] <- tempx[[1]]$name\n\t}\nboldfamilies <- sort(unlist(out0))\n\n# Remove families that return errors (private entries exist in BOLD so they can be found \"downstream\" of their respective phyla, but don't permit downloads of any barcode data and need to be excluded before the next phase\n\n# As taxonomy gets reclassified, and barcode coverage improves, the families below may need to be updated depending on when this analysis is being run. The families below did not have public records at the time we ran our analysis, but they may as database coverage improves over time\nboldfamilies <- boldfamilies[which(boldfamilies != \"Chonecoleaceae\")]\t# in BOLD but nothing public\nboldfamilies <- boldfamilies[which(boldfamilies != \"Cytinaceae\")]\t# in BOLD but nothing public \nboldfamilies <- boldfamilies[which(boldfamilies != \"Eropodiaceae\")]\t# in BOLD but nothing public\nboldfamilies <- boldfamilies[which(boldfamilies != \"Hydnoraceae\")]\t# in BOLD but nothing public\nboldfamilies<-boldfamilies[which(boldfamilies != \"Labiatae\")]\t# in BOLD but nothing public\nboldfamilies<-boldfamilies[which(boldfamilies != \"Leucobryaceae\")]\t# in BOLD but nothing public\nboldfamilies<-boldfamilies[which(boldfamilies != \"Scrophularaceae\")]\t# misspelling in BOLD but nothing public\nboldfamilies<-boldfamilies[which(boldfamilies != \"Sterculiaceae\")]\t# in BOLD but nothing public\nboldfamilies<-boldfamilies[which(boldfamilies != \"Kahakuloaceae\")]\n# Length of boldfamilies plus those that have no public data (hashed out above) is how many land plant families BOLD recognizes\n\nnopublicrecords <- c(\"Chonecoleaceae\", \"Cytinaceae\", \"Eropodiaceae\", \"Hydnoraceae\", \"Labiatae\", \"Leucobryaceae\", \"Scrophularaceae\", \"Sterculiaceae\", \"Kahakuloaceae\")\n\n# This is where we can download the barcode data, for all families, in batches, knowing that there are public records\nout1 <- vector(\"list\", length(boldfamilies))\noutnames <- matrix(nrow = length(boldfamilies), ncol = 2)\noutnames[,1] <- boldfamilies\nmarkernames <- c(\"trnL-F\", \"rbcL\", \"matK\", \"ITS\")\n```\n:::\n\n\n\n\n## Step 3. Run a loop that outputs in each iteration a separate .csv file for each family included in the \"boldfamilies\" vector. We first split the boldfamilies object into three lists to stay within the request limits for the BOLD API.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_third <- floor((length(boldfamilies)/3))\nsecond_third <- floor(length(boldfamilies) - floor((length(boldfamilies)/3)))\nlast_third <- floor(length(boldfamilies))\n\nboldfamilies1 <- boldfamilies[1:first_third]\nboldfamilies2 <- boldfamilies[first_third:second_third]\nboldfamilies3 <- boldfamilies[second_third:last_third]\n\n# Download data for the first third of families\n\tfor(i in 1:length(boldfamilies1)){\n\t\tout1[[i]] <- bold_seqspec(boldfamilies1[i], marker = markernames)\n\t\tfilename<-paste(\"./family_csvs/\",boldfamilies1[i],\".csv\",sep = \"\")\n\t\toutnames[i,2] <- filename\n\t\twrite.csv(file = filename, out1[[i]])\n\t}\n\n# Download data for the second third of families\n\tfor(i in 2:length(boldfamilies2)){\n\t\tout1[[i]] <- bold_seqspec(boldfamilies2[i], marker = markernames)\n\t\tfilename <- paste(\"./family_csvs/\",boldfamilies2[i],\".csv\",sep = \"\")\n\t\toutnames[i,2] <- filename\n\t\twrite.csv(file = filename, out1[[i]])\n\t}\n\n# Download data for the last third of families\n\tfor(i in 2:length(boldfamilies3)){\n\t\tout1[[i]] <- bold_seqspec(boldfamilies3[i], marker = markernames)\n\t\tfilename <- paste(\"./family_csvs/\",boldfamilies3[i],\".csv\",sep = \"\")\n\t\toutnames[i,2] <- filename\n\t\twrite.csv(file = filename, out1[[i]])\n\t}\n```\n:::\n\n\n\n\n## Step 4: Write BOLD search term lists to keep track of what was included in this batch effort.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(file = \"ListofBoldPhyla_to_Families\", boldfamilies)\nboldfamilies <- read.csv(file = \"ListofBoldPhyla_to_Families\")$x\nwrite.csv(file = \"ListofBoldPhyla_to_Families_nopublicrecords\", nopublicrecords)\n```\n:::\n\n\n\n\n## Step 5: Read in the files that were output to make the composite \"combtab\" dataset across all families.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout3 <- vector(\"list\", length(boldfamilies))\n\tfor(i in 1:length(boldfamilies)){\n\t\tfiletemp <- paste(\"./family_csvs/\", boldfamilies[i],\".csv\",sep = \"\")\n\t\tif (file.exists(filetemp))\n\t\tout3[[i]] <- read.csv(filetemp)\n\t}\n```\n:::\n\n\n\n\n## Step 6: Obtain list of families that downloaded with zero entries.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzerodata <- boldfamilies[which(lapply(out3, ncol) != 81)] # 81 is the column with marker codes - this is selecting elements from boldfamilies where the corresponding elements in out3 do not have 81 columns\nwrite.csv(file = \"ListofBoldPhyla_to_Families_zerodata\", zerodata)\nout3.1 <- out3[which(lapply(out3, ncol) == 81)]\n\t\nout4 <- do.call(rbind, out3.1)\nwrite.csv(file = \"BoldPhyla_to_Families.csv\", out4)\n```\n:::\n\n\n\n\n## Step 7: load and merge \"out\" files of interest, dereplicate, and combine them in ways that list the markers\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintab <- read.csv(\"BoldPhyla_to_Families.csv\")\n\ncombtab <- intab[,1:68] # note that in the current combtab we select the following columns listed below\n\n## columns to keep: \"processid\", \"institution_storing\", \"phylum_taxID\", \"phylum_name\", \"class_taxID\", \"class_name\", \"order_taxID\", \"order_name\", \"family_taxID\", \"family_name\", \"subfamily_taxID\", \"subfamily_name\", \"genus_taxID\", \"genus_name\", \"species_taxID\", \"species_name\", \"subspecies_taxID\", \"subspecies_name\" \n\ncombtab <- combtab[which(duplicated(combtab[c(3,8,11:26)]) == F),] \n\nlength(unique(intab$family_name))\nlength(unique(combtab$family_name))\n```\n:::\n\n\n\n\n## Step 8. Annotate combtab to include barcodes associated with each specimen - rbcL, matK, trnL, ITS.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarkers <- matrix(nrow = nrow(combtab),ncol = 5, \"\")\ncolnames(markers) <- c(\"rbcL\",\"matK\",\"trnL\", \"ITS2\", \"multi\")\n\nlevels(intab$markercode)\n\nmarkers[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"rbcL\", \"rbcLa\")),]$processid),1] <- \"rbcL\"\n\nmarkers[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"matK\")),]$processid),2] <- \"matK\"\n\nmarkers[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"trnL\", \"trnL-F\")),]$processid),3] <- \"trnL\"\n\nmarkers[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"ITS\", \"ITS2\")),]$processid),4] <- \"ITS\"\n\nmarkers[,5] <- apply(markers[,1:4] , 1, paste , collapse = \"-\" )\n\nmarker_df <- as.data.frame(markers)\nunique(marker_df$multi)\n```\n:::\n\n\n\n\n## Step 9. Save GENBANK information and combine markers list to combtab object\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save genbank info\ngenbank <- matrix(nrow = nrow(combtab),ncol = 4, \"\")\ncolnames(genbank) <- c(\"gb_rbcL\",\"gb_matK\",\"gb_trnL\", \"gb_ITS\")\n\ngenbank[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"rbcL\", \"rbcLa\")),]$processid),1] <-intab[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"rbcL\", \"rbcLa\")),]$processid),]$genbank_accession\n\ngenbank[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"matK\")),]$processid),2] <- intab[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"matK\")),]$processid),]$genbank_accession\n\ngenbank[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"trnL-F\")),]$processid),3] <- intab[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"trnL\", \"trnL-F\")),]$processid),]$genbank_accession\n\ngenbank[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"ITS\", \"ITS2\")),]$processid),4] <- intab[which(combtab$processid %in% intab[which(intab$markercode %in% c(\"ITS\", \"ITS2\")),]$processid),]$genbank_accession\n\n# Combine markers list to combtab\ncombtab <- cbind(combtab, markers, genbank)\n```\n:::\n\n\n\n\n## Step 10. Filter columns that make the file unnecessarily large and write combtab object\n\nThis block will generate the same file structure as dataset S1 in the Supplement.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(combtab)\ncombtabout <- combtab[, c(2:3,8,11:26,35:36,49:53,57:61,69:77)]\nhead(combtabout, 2)\nwrite.csv(file = \"../data/Kartzinel_et_al_Dataset_S1_20240725.csv\", combtabout)\n```\n:::\n",
    "supporting": [
      "building_bold_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}